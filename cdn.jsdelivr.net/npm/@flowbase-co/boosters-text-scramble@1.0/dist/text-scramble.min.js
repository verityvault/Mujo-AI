/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/@flowbase-co/boosters-text-scramble@1.0.0/dist/text-scramble.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
(function() {
    "use strict";
    const s = {
            trigger: "hover",
            type: "forward"
        },
        c = r => Math.floor(Math.random() * r),
        i = () => {
            const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
                t = "<>[]()/:;.-_?!%$*+=#&@",
                e = " ",
                n = [...r.split(""), ...t.split(""), e];
            return n[c(n.length)]
        };
    class o {
        constructor(t) {
            var e;
            this.element = t, this.originalTextContent = ((e = this.element.textContent) == null ? void 0 : e.trim()) || "", this.interval, this.type = t.getAttribute("fb-scramble-type") || s.type
        }
        get speed() {
            const t = Number(this.element.getAttribute("fb-scramble-speed"));
            return t || (this.type === "all" ? 60 : 20)
        }
        get count() {
            const t = Number(this.element.getAttribute("fb-scramble-count"));
            return t || (this.type === "all" ? 15 : 5)
        }
        scrambleAll() {
            const t = this.originalTextContent.split("");
            let e = 0;
            this.interval = setInterval(() => {
                if (e >= this.count) {
                    this.unscramble();
                    return
                }
                t.map((n, m) => t[m] = i()), e += 1, this.element.textContent = t.join("")
            }, this.speed)
        }
        scrambleForward() {
            const t = this.originalTextContent.split("");
            let e = 0,
                n = 0;
            this.interval = setInterval(() => {
                if (e >= this.originalTextContent.length) {
                    this.unscramble();
                    return
                }
                n >= this.count ? (t[e] = this.originalTextContent[e], e += 1, n = 0) : (t[e] = i(), n += 1), this.element.textContent = t.join("")
            }, this.speed)
        }
        scramble() {
            this.originalTextContent && (this.type === "all" && this.scrambleAll(), this.type === "forward" && this.scrambleForward())
        }
        unscramble() {
            this.element.textContent = this.originalTextContent, this.interval && clearInterval(this.interval)
        }
    }
    const h = r => {
            new o(r).scramble()
        },
        b = r => {
            const t = new o(r);
            r.addEventListener("mouseover", () => t.scramble()), r.addEventListener("mouseleave", () => t.unscramble())
        },
        l = new IntersectionObserver(r => {
            r.forEach(t => {
                t.isIntersecting && (h(t.target), l.unobserve(t.target))
            })
        }, {
            threshold: 1
        }),
        a = async () => {
            document.querySelectorAll("[fb-scramble]").forEach(t => {
                if (!t.textContent) return;
                const e = t.getAttribute("fb-scramble-trigger") || s.trigger;
                e === "view" && l.observe(t), e === "hover" && b(t)
            })
        };
    document.readyState === "complete" ? a() : window.addEventListener("load", a)
})();